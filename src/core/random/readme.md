## 算法原理

1. 首先通过[`optimize (optimize.ts#L27)`](./optimize.ts#L27)函数对原始学生数据进行了处理，过滤掉了一些特定的学生。

2. 然后根据剩余学生的数量，创建了一个序号数组。

3. 接着打乱这个序号数组，并取前$\,\frac23\,$的部分序号。

4. 创建一个函数，每次调用这个函数都会从剩余的$\,\frac13\,$序号中随机取出一个，即随机取出一名还没被选择的学生。

5. 每取出一个学生后，就把这个序号从$\,\frac13\,$序号中移除，下次就不会再次取到。

## 算法优势

1. 保证了每个人都有相等的机会被选中：通过先生成一个包含所有学生序号的数组，再打乱顺序，每个序号对应一个学生，从而确保每个学生被选中的概率相等。

2. 避免了重复选中：每次从剩余序号中随机选取一个，并将其从序号数组中移除，从而避免同一个学生被重复选中。

3. 控制了随机选取的数量比例：代码中将序号数组划分为前$\,\frac23\,$和后$\,\frac13\,$两部分，前$\,\frac23\,$的序号对应会被全部选取，后$\,\frac13\,$则作为剩余备选。这样可以控制随机选取的数量在总数的$\,\frac23\,$左右。

4. 引入了优化机制：在随机选取之前，会先函数过滤掉一些特定的学生，从而确保随机选取的结果符合一定条件。

5. 实现了可复用性：将随机选取逻辑封装在一个函数中，便于在不同场景下重复使用该算法。

## 备注

如果你不想被选中，且不想通过显式地更改`config.fn.random[].val`实现，可以将你的名字的32位MD5值加入[`optimizeMD5 (optimize.ts#L4)`](./optimize.ts#L4)。